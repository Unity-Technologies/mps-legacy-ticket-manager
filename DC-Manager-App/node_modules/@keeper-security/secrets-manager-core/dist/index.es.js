/* Version: 16.6.2 - January 24, 2024 00:15:52 */
/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

function connectPlatform(p) {
    platform = p;
}
let platform;
const loadJsonConfig = (config) => {
    let jsonStr = config;
    try {
        const str = platform.bytesToString(platform.base64ToBytes(config));
        if (str.trimStart().startsWith('{') && str.trimEnd().endsWith('}'))
            jsonStr = str;
    }
    catch (e) {
        jsonStr = config;
    }
    return inMemoryStorage(JSON.parse(jsonStr));
};
const inMemoryStorage = (storage) => {
    const getValue = (key) => {
        const keyParts = key.split('/');
        let obj = storage;
        for (const part of keyParts) {
            obj = obj[part];
            if (!obj) {
                return undefined;
            }
        }
        return obj.toString();
    };
    const saveValue = (key, value) => {
        const keyParts = key.split('/');
        let obj = storage;
        for (const part of keyParts.slice(0, -1)) {
            if (!obj[part]) {
                obj[part] = {};
            }
            obj = obj[part];
        }
        obj[keyParts.slice(-1)[0]] = value;
    };
    const clearValue = (key) => {
        const keyParts = key.split('/');
        let obj = storage;
        for (const part of keyParts.slice(0, -1)) {
            if (!obj[part]) {
                obj[part] = {};
            }
            obj = obj[part];
        }
        delete obj[keyParts.slice(-1)[0]];
    };
    return {
        getString: key => Promise.resolve(getValue(key)),
        saveString: (key, value) => {
            saveValue(key, value);
            return Promise.resolve();
        },
        getBytes: key => {
            const bytesString = getValue(key);
            if (bytesString) {
                return Promise.resolve(platform.base64ToBytes(bytesString));
            }
            else {
                return Promise.resolve(undefined);
            }
        },
        saveBytes: (key, value) => {
            const bytesString = platform.bytesToBase64(value);
            saveValue(key, bytesString);
            return Promise.resolve();
        },
        delete: (key) => {
            clearValue(key);
            return Promise.resolve();
        }
    };
};

const webSafe64 = (source) => source.replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
const webSafe64ToRegular = (source) => source.replace(/-/g, '+').replace(/_/g, '/') + '=='.substring(0, (3 * source.length) % 4);
const webSafe64ToBytes = (source) => platform.base64ToBytes(webSafe64ToRegular(source));
const webSafe64FromBytes = (source) => webSafe64(platform.bytesToBase64(source));
// extracts public raw from private key for prime256v1 curve in der/pkcs8
// privateKey: key.slice(36, 68)
const privateDerToPublicRaw = (key) => key.slice(-65);
const b32encode = (base32Text) => {
    /* encodes a string to base32 and returns the encoded string */
    const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567';
    // The padding specified in RFC 3548 section 2.2 is not required and should be omitted.
    const base32 = (base32Text || '').replace(/=+$/g, '').toUpperCase();
    if (!base32 || !/^[A-Z2-7]+$/.test(base32))
        return new Uint8Array();
    const bytes = Array.from(base32);
    let output = new Array();
    for (let bitIndex = 0; bitIndex < base32.length * 5; bitIndex += 8) {
        const idx = Math.floor(bitIndex / 5);
        let dualByte = alphabet.indexOf(bytes[idx]) << 10;
        if (idx + 1 < bytes.length)
            dualByte |= alphabet.indexOf(bytes[idx + 1]) << 5;
        if (idx + 2 < bytes.length)
            dualByte |= alphabet.indexOf(bytes[idx + 2]);
        dualByte = 0xff & (dualByte >> (15 - bitIndex % 5 - 8));
        output.push(dualByte);
    }
    return new Uint8Array(output);
};
const getTotpCode = (url, unixTimeSeconds = 0) => __awaiter(void 0, void 0, void 0, function* () {
    let totpUrl;
    try {
        totpUrl = new URL(url);
    }
    catch (e) {
        return null;
    }
    if (totpUrl.protocol != 'otpauth:')
        return null;
    const secret = (totpUrl.searchParams.get('secret') || '').trim();
    if (!secret)
        return null;
    let algorithm = (totpUrl.searchParams.get('algorithm') || '').trim();
    if (!algorithm)
        algorithm = 'SHA1'; // default algorithm
    const strDigits = (totpUrl.searchParams.get('digits') || '').trim();
    let digits = ((isNaN(+strDigits) || !Boolean(strDigits)) ? 6 : parseInt(strDigits));
    digits = digits == 0 ? 6 : digits;
    const strPeriod = (totpUrl.searchParams.get('period') || '').trim();
    let period = ((isNaN(+strPeriod) || !Boolean(strPeriod)) ? 30 : parseInt(strPeriod));
    period = period == 0 ? 30 : period;
    const tmBase = unixTimeSeconds != 0 ? unixTimeSeconds : Math.floor(Date.now() / 1000);
    const tm = BigInt(Math.floor(tmBase / period));
    const buffer = new ArrayBuffer(8);
    new DataView(buffer).setBigInt64(0, tm);
    const msg = new Uint8Array(buffer);
    const secretBytes = b32encode(secret.toUpperCase());
    if (secretBytes == null || secretBytes.length < 1)
        return null;
    const digest = yield platform.getHmacDigest(algorithm, secretBytes, msg);
    if (digest.length < 1)
        return null;
    const offset = digest[digest.length - 1] & 0x0f;
    const codeBytes = new Uint8Array(digest.slice(offset, offset + 4));
    codeBytes[0] &= 0x7f;
    let codeInt = new DataView(codeBytes.buffer).getInt32(0);
    codeInt %= Math.floor(Math.pow(10, digits));
    codeInt = Math.floor(codeInt);
    let codeStr = codeInt.toString(10);
    while (codeStr.length < digits)
        codeStr = '0' + codeStr;
    const elapsed = Math.floor(tmBase % period); // time elapsed in current period in seconds
    const ttl = period - elapsed; // time to live in seconds
    return { code: codeStr, timeLeft: ttl, period: period };
});
// password generation
const defaultPasswordLength = 32;
const asciiSpecialCharacters = '"!@#$%()+;<>=?[]{}^.,';
const asciiLowercase = 'abcdefghijklmnopqrstuvwxyz';
const asciiUppercase = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
const asciiDigits = '0123456789';
const shuffle = (text) => __awaiter(void 0, void 0, void 0, function* () {
    // Fisher-Yates shuffle
    let result = text;
    if (result.length > 1) {
        let a = result.split('');
        for (let i = a.length - 1; i > 0; i--) {
            const j = yield platform.getRandomNumber(i + 1); // 0 <= j <= i
            if (i != j) {
                const tmp = a[i];
                a[i] = a[j];
                a[j] = tmp;
            }
        }
        result = a.join('');
    }
    return result;
});
const randomSample = (length, charset) => __awaiter(void 0, void 0, void 0, function* () {
    let result = '';
    length = Math.abs(length);
    for (let i = 0; i < length; i++)
        result += yield platform.getRandomCharacterInCharset(charset);
    return result;
});
/**
 * Generates a new password of specified minimum length
 * using provided number of uppercase, lowercase, digits and special characters.
 *
 * Note: If all character groups are unspecified or all have exact zero length
 * then password characters are chosen from all groups uniformly at random.
 *
 * Note: If all charset lengths are negative or 0 but can't reach min_length
 * then all exact/negative charset lengths will be treated as minimum number of characters instead.
 *
 * @param {number} minLength - Minimum password length - default: 32
 * @param {number|null} lowercase - Minimum number of lowercase characters if positive, exact if 0 or negative
 * @param {number|null} uppercase - Minimum number of uppercase characters if positive, exact if 0 or negative
 * @param {number|null} digits - Minimum number of digits if positive, exact if 0 or negative
 * @param {number|null} specialCharacters - Minimum number of special characters if positive, exact if 0 or negative
 * @param {number} specialCharacterSet - String containing custom set of special characters to pick from
 * @returns {string} Generated password string
 */
const generatePassword = (minLength = defaultPasswordLength, lowercase = null, uppercase = null, digits = null, specialCharacters = null, specialCharacterSet = asciiSpecialCharacters) => __awaiter(void 0, void 0, void 0, function* () {
    var _a, _b;
    const counts = [lowercase, uppercase, digits, specialCharacters];
    const sumCategories = (_a = counts.reduce((sum, x) => sum + Math.abs(x !== null && x !== void 0 ? x : 0), 0)) !== null && _a !== void 0 ? _a : 0;
    // If all lengths are exact/negative but don't reach minLength - convert to minimum/positive lengths
    const numExactCounts = (_b = counts.reduce((sum, x) => sum + (((x !== null && x !== void 0 ? x : 1) <= 0) ? 1 : 0), 0)) !== null && _b !== void 0 ? _b : 0;
    if (counts.length == numExactCounts && sumCategories < minLength) {
        if ((lowercase !== null && lowercase !== void 0 ? lowercase : 0) < 0)
            lowercase = Math.abs(lowercase !== null && lowercase !== void 0 ? lowercase : 0);
        if ((uppercase !== null && uppercase !== void 0 ? uppercase : 0) < 0)
            uppercase = Math.abs(uppercase !== null && uppercase !== void 0 ? uppercase : 0);
        if ((digits !== null && digits !== void 0 ? digits : 0) < 0)
            digits = Math.abs(digits !== null && digits !== void 0 ? digits : 0);
        if ((specialCharacters !== null && specialCharacters !== void 0 ? specialCharacters : 0) < 0)
            specialCharacters = Math.abs(specialCharacters !== null && specialCharacters !== void 0 ? specialCharacters : 0);
    }
    let extraChars = '';
    let extraCount = 0;
    if (minLength > sumCategories)
        extraCount = minLength - sumCategories;
    if ((lowercase !== null && lowercase !== void 0 ? lowercase : 1) > 0)
        extraChars += asciiLowercase;
    if ((uppercase !== null && uppercase !== void 0 ? uppercase : 1) > 0)
        extraChars += asciiUppercase;
    if ((digits !== null && digits !== void 0 ? digits : 1) > 0)
        extraChars += asciiDigits;
    if ((specialCharacters !== null && specialCharacters !== void 0 ? specialCharacters : 1) > 0)
        extraChars += specialCharacterSet;
    if (extraCount > 0 && !extraChars)
        extraChars = asciiLowercase + asciiUppercase + asciiDigits + specialCharacterSet;
    const categoryMap = [
        { count: Math.abs(lowercase !== null && lowercase !== void 0 ? lowercase : 0), chars: asciiLowercase },
        { count: Math.abs(uppercase !== null && uppercase !== void 0 ? uppercase : 0), chars: asciiUppercase },
        { count: Math.abs(digits !== null && digits !== void 0 ? digits : 0), chars: asciiDigits },
        { count: Math.abs(specialCharacters !== null && specialCharacters !== void 0 ? specialCharacters : 0), chars: specialCharacterSet },
        { count: extraCount, chars: extraChars }
    ];
    let passwordCharacters = '';
    for (let i = 0; i < categoryMap.length; i++)
        if (categoryMap[i].count > 0)
            passwordCharacters += yield randomSample(categoryMap[i].count, categoryMap[i].chars);
    const password = yield shuffle(passwordCharacters);
    return password;
});
/**
 * Try to parse an integer value from a string. Returns the number if successful, otherwise return a default value.
 * @param value The string with an integer to parse.
 * @param defaultValue Default value to return if parsing fails.
 */
function tryParseInt(value, defaultValue = 0) {
    let parsedValue = parseInt(value, 10);
    if (isNaN(parsedValue))
        return defaultValue; // Failed to parse. Return the default value.
    else
        return parsedValue; // Return the parsed value.
}

const bytesToBase64 = (data) => {
    const chunkSize = 0x10000; // max size accepted by String.fromCharCode
    if (data.length <= chunkSize) {
        // @ts-ignore
        return btoa(String.fromCharCode(...data));
    }
    let chunks = '';
    for (let i = 0; i < data.length; i = i + chunkSize) {
        // @ts-ignore
        chunks = chunks + String.fromCharCode(...data.slice(i, i + chunkSize));
    }
    return btoa(chunks);
};
const base64ToBytes = (data) => Uint8Array.from(atob(data), c => c.charCodeAt(0));
const bytesToString = (data) => new TextDecoder().decode(data);
const stringToBytes = (data) => new TextEncoder().encode(data);
const getRandomBytes = (length) => {
    const data = new Uint8Array(length);
    crypto.getRandomValues(data);
    return data;
};
const keyCache = {};
const loadPrivateKey = (keyId, storage) => __awaiter(void 0, void 0, void 0, function* () {
    const cachedPrivateKey = keyCache[keyId];
    if (cachedPrivateKey) {
        return cachedPrivateKey;
    }
    let privateKey;
    if (storage.getObject) {
        const keyPair = yield storage.getObject(keyId);
        if (keyPair) {
            privateKey = keyPair.privateKey;
        }
    }
    else {
        const privateKeyDer = yield storage.getBytes(keyId);
        if (privateKeyDer) {
            privateKey = yield crypto.subtle.importKey('pkcs8', privateKeyDer, {
                name: 'ECDSA',
                namedCurve: 'P-256'
            }, false, ['sign']);
        }
    }
    if (!privateKey) {
        throw new Error(`Unable to load the private key ${keyId}`);
    }
    keyCache[keyId] = privateKey;
    return privateKey;
});
const loadKey = (keyId, storage) => __awaiter(void 0, void 0, void 0, function* () {
    const cachedKey = keyCache[keyId];
    if (cachedKey) {
        return cachedKey;
    }
    let key;
    if (storage) {
        if (storage.getObject) {
            key = yield storage.getObject(keyId);
        }
        else {
            const keyBytes = yield storage.getBytes(keyId);
            if (keyBytes) {
                key = yield crypto.subtle.importKey('raw', keyBytes, 'AES-GCM', false, ['encrypt', 'decrypt', 'unwrapKey']);
            }
        }
    }
    if (!key) {
        throw new Error(`Unable to load the key ${keyId}`);
    }
    keyCache[keyId] = key;
    return key;
});
const generatePrivateKey = (keyId, storage) => __awaiter(void 0, void 0, void 0, function* () {
    const keyPair = yield crypto.subtle.generateKey({ name: 'ECDSA', namedCurve: 'P-256' }, !storage.saveObject, ['sign', 'verify']);
    keyCache[keyId] = keyPair.privateKey;
    if (storage.saveObject) {
        yield storage.saveObject(keyId, keyPair);
    }
    else {
        // @ts-ignore
        const privateKey = yield crypto.subtle.exportKey('pkcs8', keyPair.privateKey);
        yield storage.saveBytes(keyId, new Uint8Array(privateKey));
    }
});
const exportPublicKey = (keyId, storage) => __awaiter(void 0, void 0, void 0, function* () {
    if (storage.getObject) {
        const keyPair = yield storage.getObject(keyId);
        if (keyPair) {
            // @ts-ignore
            const publicKey = yield crypto.subtle.exportKey('raw', keyPair.publicKey);
            return new Uint8Array(publicKey);
        }
    }
    else {
        const privateKeyDer = yield storage.getBytes(keyId);
        if (privateKeyDer) {
            return privateDerToPublicRaw(privateKeyDer);
        }
    }
    throw new Error(`Unable to load the key ${keyId}`);
});
// derived from https://github.com/litert/signatures.js
const p1363ToDER = (p1363) => {
    const ecdsaRecoverRS = (input) => {
        let start = 0;
        while (input[start] === 0) {
            start++;
        }
        if (input[start] <= 0x7F) {
            return input.slice(start);
        }
        if (start > 0) {
            return input.slice(start - 1);
        }
        const output = Buffer.alloc(input.length + 1);
        input.copy(output, 1);
        output[0] = 0;
        return output;
    };
    let base = 0;
    let r;
    let s;
    const hL = p1363.length / 2;
    /**
     * Prepend a 0x00 byte to R or S if it starts with a byte larger than 0x79.
     *
     * Because a integer starts with a byte larger than 0x79 means negative.
     *
     * @see https://bitcointalk.org/index.php?topic=215205.msg2258789#msg2258789
     */
    r = ecdsaRecoverRS(p1363.slice(0, hL));
    s = ecdsaRecoverRS(p1363.slice(hL));
    /**
     * Using long form length if it's larger than 0x7F.
     *
     * @see https://stackoverflow.com/a/47099047
     */
    if (4 + s.length + r.length > 0x7f) {
        base++;
    }
    const der = Buffer.alloc(base + 6 + s.length + r.length);
    if (base) {
        der[1] = 0x81;
    }
    der[0] = 0x30;
    der[base + 1] = 4 + s.length + r.length;
    der[base + r.length + 4] = der[base + 2] = 0x02;
    der[base + r.length + 5] = s.length;
    der[base + 3] = r.length;
    r.copy(der, base + 4);
    s.copy(der, base + 6 + r.length);
    return der;
};
const sign = (data, keyId, storage) => __awaiter(void 0, void 0, void 0, function* () {
    const privateKey = yield loadPrivateKey(keyId, storage);
    const signature = yield crypto.subtle.sign({
        name: 'ECDSA',
        hash: 'SHA-256'
    }, privateKey, data);
    return new Uint8Array(p1363ToDER(Buffer.from(signature)));
});
const importKey = (keyId, key, storage) => __awaiter(void 0, void 0, void 0, function* () {
    const _key = yield crypto.subtle.importKey('raw', key, 'AES-GCM', false, ['encrypt', 'decrypt', 'unwrapKey']);
    keyCache[keyId] = _key;
    if (storage) {
        if (storage.saveObject) {
            yield storage.saveObject(keyId, _key);
        }
        else {
            yield storage.saveBytes(keyId, key);
        }
    }
});
const encrypt = (data, keyId, storage, useCBC) => __awaiter(void 0, void 0, void 0, function* () {
    const key = yield loadKey(keyId, storage);
    return __encrypt(data, key, useCBC);
});
const _encrypt = (data, key, useCBC) => __awaiter(void 0, void 0, void 0, function* () {
    const _key = yield crypto.subtle.importKey('raw', key, 'AES-GCM', false, ['encrypt']);
    return __encrypt(data, _key, useCBC);
});
const __encrypt = (data, key, useCBC) => __awaiter(void 0, void 0, void 0, function* () {
    const ivLen = useCBC ? 16 : 12;
    const algorithmName = useCBC ? 'AES-CBC' : 'AES-GCM';
    const iv = getRandomBytes(ivLen);
    const res = yield crypto.subtle.encrypt({
        name: algorithmName,
        iv: iv
    }, key, data);
    return Uint8Array.of(...iv, ...new Uint8Array(res));
});
const unwrap = (key, keyId, unwrappingKeyId, storage, memoryOnly, useCBC) => __awaiter(void 0, void 0, void 0, function* () {
    const unwrappingKey = yield loadKey(unwrappingKeyId, storage);
    if (!unwrappingKey.usages.includes('unwrapKey')) {
        throw new Error(`Key ${unwrappingKeyId} is not suitable for unwrapping`);
    }
    const ivLen = useCBC ? 16 : 12;
    const algorithmName = useCBC ? 'AES-CBC' : 'AES-GCM';
    const unwrappedKey = yield crypto.subtle.unwrapKey('raw', key.subarray(ivLen), unwrappingKey, {
        iv: key.subarray(0, ivLen),
        name: algorithmName
    }, algorithmName, storage ? !storage.saveObject : false, ['encrypt', 'decrypt', 'unwrapKey']);
    keyCache[keyId] = unwrappedKey;
    if (memoryOnly) {
        return;
    }
    if (storage) {
        if (storage.saveObject) {
            yield storage.saveObject(keyId, unwrappedKey);
        }
        else {
            const keyArray = yield crypto.subtle.exportKey('raw', unwrappedKey);
            const keyBytes = new Uint8Array(keyArray);
            yield storage.saveBytes(keyId, keyBytes);
        }
    }
});
const decrypt = (data, keyId, storage, useCBC) => __awaiter(void 0, void 0, void 0, function* () {
    const key = yield loadKey(keyId, storage);
    return __decrypt(data, key, useCBC);
});
const _decrypt = (data, key, useCBC) => __awaiter(void 0, void 0, void 0, function* () {
    const _key = yield crypto.subtle.importKey('raw', key, 'AES-GCM', false, ['decrypt']);
    return __decrypt(data, _key, useCBC);
});
const __decrypt = (data, key, useCBC) => __awaiter(void 0, void 0, void 0, function* () {
    const ivLen = useCBC ? 16 : 12;
    const algorithmName = useCBC ? 'AES-CBC' : 'AES-GCM';
    const iv = data.subarray(0, ivLen);
    const encrypted = data.subarray(ivLen);
    const res = yield crypto.subtle.decrypt({
        name: algorithmName,
        iv: iv
    }, key, encrypted);
    return new Uint8Array(res);
});
const hash = (data, tag) => __awaiter(void 0, void 0, void 0, function* () {
    const key = yield crypto.subtle.importKey('raw', data, {
        name: 'HMAC',
        hash: {
            name: 'SHA-512'
        }
    }, false, ['sign']);
    const signature = yield crypto.subtle.sign('HMAC', key, stringToBytes(tag));
    return new Uint8Array(signature);
});
const publicEncrypt = (data, key, id) => __awaiter(void 0, void 0, void 0, function* () {
    const ephemeralKeyPair = yield crypto.subtle.generateKey({
        name: 'ECDH',
        namedCurve: 'P-256'
    }, false, ['deriveBits']);
    // @ts-ignore
    const ephemeralPublicKey = yield crypto.subtle.exportKey('raw', ephemeralKeyPair.publicKey);
    const recipientPublicKey = yield crypto.subtle.importKey('raw', key, {
        name: 'ECDH',
        namedCurve: 'P-256'
    }, true, []);
    const sharedSecret = yield crypto.subtle.deriveBits({
        name: 'ECDH',
        public: recipientPublicKey
    }, ephemeralKeyPair.privateKey, 256);
    const idBytes = id || new Uint8Array();
    const sharedSecretCombined = new Uint8Array(sharedSecret.byteLength + idBytes.byteLength);
    sharedSecretCombined.set(new Uint8Array(sharedSecret), 0);
    sharedSecretCombined.set(idBytes, sharedSecret.byteLength);
    const symmetricKey = yield crypto.subtle.digest('SHA-256', sharedSecretCombined);
    const cipherText = yield _encrypt(data, new Uint8Array(symmetricKey));
    const result = new Uint8Array(ephemeralPublicKey.byteLength + cipherText.byteLength);
    result.set(new Uint8Array(ephemeralPublicKey), 0);
    result.set(new Uint8Array(cipherText), ephemeralPublicKey.byteLength);
    return result;
});
const get = (url, headers) => __awaiter(void 0, void 0, void 0, function* () {
    const resp = yield fetch(url, {
        method: 'GET',
        headers: Object.entries(headers),
    });
    const body = yield resp.arrayBuffer();
    return {
        statusCode: resp.status,
        headers: resp.headers,
        data: new Uint8Array(body)
    };
});
const post = (url, request, headers) => __awaiter(void 0, void 0, void 0, function* () {
    const resp = yield fetch(url, {
        method: 'POST',
        headers: new Headers(Object.assign({ 'Content-Type': 'application/octet-stream', 'Content-Length': String(request.length) }, headers)),
        body: request,
    });
    const body = yield resp.arrayBuffer();
    return {
        statusCode: resp.status,
        headers: resp.headers,
        data: new Uint8Array(body)
    };
});
const fileUpload = (url, uploadParameters, data) => new Promise((resolve, reject) => {
    const form = new FormData();
    for (const key in uploadParameters) {
        form.append(key, uploadParameters[key]);
    }
    form.append('file', data);
    const fetchCfg = {
        method: 'PUT',
        body: form,
    };
    fetch(url, fetchCfg)
        .then(response => response.json())
        .then(res => {
        resolve({
            headers: res.headers,
            statusCode: res.statusCode,
            statusMessage: res.statusMessage
        });
    })
        .catch(error => {
        console.error('Error uploading file:', error);
        reject(error);
    });
});
const cleanKeyCache = () => {
    for (const key in keyCache) {
        delete keyCache[key];
    }
};
const hasKeysCached = () => {
    return Object.keys(keyCache).length > 0;
};
const getHmacDigest = (algorithm, secret, message) => __awaiter(void 0, void 0, void 0, function* () {
    // although once part of Google Key Uri Format - https://github.com/google/google-authenticator/wiki/Key-Uri-Format/_history
    // removed MD5 as unreliable - only digests of length >= 20 can be used (MD5 has a digest length of 16)
    let algo = algorithm.toUpperCase().trim();
    if (['SHA1', 'SHA256', 'SHA512'].includes(algo)) {
        algo = 'SHA-' + algo.substr(3);
        const key = yield crypto.subtle.importKey('raw', secret, {
            name: 'HMAC',
            hash: { name: algo }
        }, false, ['sign']);
        const signature = yield crypto.subtle.sign('HMAC', key, message);
        return new Uint8Array(signature);
    }
    return new Uint8Array();
});
// Returns a sufficiently random number in the range [0, max) i.e. 0 <= number < max
const getRandomNumber = (n) => __awaiter(void 0, void 0, void 0, function* () {
    const uint32Max = Math.pow(2, 32) - 1;
    const limit = uint32Max - uint32Max % n;
    let values = new Uint32Array(1);
    do {
        const randomBytes = getRandomBytes(4);
        values = new Uint32Array(randomBytes.buffer);
    } while (values[0] > limit);
    return Promise.resolve(values[0] % n);
});
// Given a character set, this function will return one sufficiently random character from the charset.
const getRandomCharacterInCharset = (charset) => __awaiter(void 0, void 0, void 0, function* () {
    const count = charset.length;
    const pos = yield getRandomNumber(count);
    return Promise.resolve(charset[pos]);
});
const browserPlatform = {
    bytesToBase64: bytesToBase64,
    base64ToBytes: base64ToBytes,
    bytesToString: bytesToString,
    stringToBytes: stringToBytes,
    getRandomBytes: getRandomBytes,
    generatePrivateKey: generatePrivateKey,
    exportPublicKey: exportPublicKey,
    importKey: importKey,
    unwrap: unwrap,
    encrypt: encrypt,
    encryptWithKey: _encrypt,
    decrypt: decrypt,
    decryptWithKey: _decrypt,
    hash: hash,
    publicEncrypt: publicEncrypt,
    sign: sign,
    get: get,
    post: post,
    fileUpload: fileUpload,
    cleanKeyCache: cleanKeyCache,
    hasKeysCached: hasKeysCached,
    getHmacDigest: getHmacDigest,
    getRandomNumber: getRandomNumber,
    getRandomCharacterInCharset: getRandomCharacterInCharset
};

function getValue(secrets, notation) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u;
    const parsedNotation = parseNotation(notation, true); // prefix, record, selector, footer
    if (parsedNotation.length < 3)
        throw Error(`Invalid notation ${notation}`);
    if (parsedNotation[2].text == null)
        throw Error(`Invalid notation ${notation}`);
    const selector = parsedNotation[2].text[0]; // type|title|notes or file|field|custom_field
    if (parsedNotation[1].text == null)
        throw Error(`Invalid notation ${notation}`);
    const recordToken = parsedNotation[1].text[0]; // UID or Title
    const record = secrets.records.find(x => x.recordUid === recordToken || x.data.title === recordToken);
    if (!record)
        throw Error(`Record '${recordToken}' not found`);
    const parameter = (_c = (_b = (_a = parsedNotation[2]) === null || _a === void 0 ? void 0 : _a.parameter) === null || _b === void 0 ? void 0 : _b.at(0)) !== null && _c !== void 0 ? _c : null;
    const index1 = (_f = (_e = (_d = parsedNotation[2]) === null || _d === void 0 ? void 0 : _d.index1) === null || _e === void 0 ? void 0 : _e.at(0)) !== null && _f !== void 0 ? _f : null;
    const index2 = (_j = (_h = (_g = parsedNotation[2]) === null || _g === void 0 ? void 0 : _g.index2) === null || _h === void 0 ? void 0 : _h.at(0)) !== null && _j !== void 0 ? _j : null;
    switch (selector.toLowerCase()) {
        case 'type': return (_k = record.data.type) !== null && _k !== void 0 ? _k : '';
        case 'title': return (_l = record.data.title) !== null && _l !== void 0 ? _l : '';
        case 'notes': return (_m = record.data.notes) !== null && _m !== void 0 ? _m : '';
        case 'file': {
            if (parameter == null)
                throw Error(`Notation error - Missing required parameter: filename or file UID for files in record '${recordToken}'`);
            if (((_p = (_o = record === null || record === void 0 ? void 0 : record.files) === null || _o === void 0 ? void 0 : _o.length) !== null && _p !== void 0 ? _p : 0) < 1)
                throw Error(`Notation error - Record ${recordToken} has no file attachments.`);
            let files = (_q = record.files) !== null && _q !== void 0 ? _q : [];
            files = files.filter(x => { var _a, _b; return parameter == ((_a = x.data) === null || _a === void 0 ? void 0 : _a.name) || parameter == ((_b = x.data) === null || _b === void 0 ? void 0 : _b.title) || parameter == x.fileUid; });
            // file searches do not use indexes and rely on unique file names or fileUid
            if (((_r = files === null || files === void 0 ? void 0 : files.length) !== null && _r !== void 0 ? _r : 0) < 1)
                throw Error(`Notation error - Record ${recordToken} has no files matching the search criteria '${parameter}'`);
            // legacy compat. mode
            return files[0];
            // if ((files?.length ?? 0) > 1)
            //     throw Error(`Notation error - Record ${recordToken} has multiple files matching the search criteria '${parameter}'`)
            // try {
            //     const contents = await downloadFile(files[0])
            //     const text = webSafe64FromBytes(contents)
            //     return text
            // } catch (e) { throw Error(`Notation error - download failed for Record: ${recordToken}, File: ${parameter}, FileUID: ${files[0].fileUid}, Message: ${e}`)}
        }
        case 'field':
        case 'custom_field': {
            if (parameter == null)
                throw Error(`Notation error - Missing required parameter for the field (type or label): ex. /field/type or /custom_field/MyLabel`);
            const fields = (selector.toLowerCase() == 'field' ? record.data.fields :
                selector.toLowerCase() == 'custom_field' ? record.data.custom : null);
            if (!fields)
                throw new Error(`Notation error - Expected /field or /custom_field but found /${selector}`);
            // legacy compat mode - find first field only
            const field = fields.find(x => parameter === x.type || parameter === x.label);
            if (!field)
                throw new Error(`Field ${parameter} not found in the record ${record.recordUid}`);
            // /<type|label>[index1][index2], ex. /url == /url[] == /url[][] == full value
            const idx = tryParseInt(index1 || '', -1); // -1 = full value
            // valid only if [] or missing - ex. /field/phone or /field/phone[]
            if (idx == -1 && !(parsedNotation[2].index1 == null || parsedNotation[2].index1[1] == '' || parsedNotation[2].index1[1] == '[]'))
                throw new Error(`Notation error - Invalid field index ${idx}.`);
            let values = ((field === null || field === void 0 ? void 0 : field.value) != null ? field.value : []);
            if (idx >= values.length)
                throw new Error(`Notation error - Field index out of bounds ${idx} >= ${values.length} for field '${parameter}' in record '${record.recordUid}'`);
            if (idx >= 0) // single index
                values = [values[idx]];
            const fullObjValue = (parsedNotation[2].index2 == null || parsedNotation[2].index2[1] == '' || parsedNotation[2].index2[1] == '[]');
            let objPropertyName = '';
            if (parsedNotation[2].index2 != null)
                objPropertyName = parsedNotation[2].index2[0];
            // legacy compatibility mode - no indexes, ex. /url returns value[0]
            if ((parsedNotation[2].index1 == null || parsedNotation[2].index1[1] == '') &&
                (parsedNotation[2].index2 == null || parsedNotation[2].index2[1] == ''))
                return values[0]; // legacy compatibility
            // return (typeof values[0] === 'string' ? values[0] as string : JSON.stringify(values[0]))
            // legacy compatibility mode - empty index, ex. /url[] returns ["value"]
            if ('[]' == ((_u = (_t = (_s = parsedNotation[2]) === null || _s === void 0 ? void 0 : _s.index1) === null || _t === void 0 ? void 0 : _t.at(1)) !== null && _u !== void 0 ? _u : '') && (index2 == null || index2 == ''))
                return values; // legacy compatibility
            // return JSON.stringify(values)
            // should be handled by parseNotation w/ legacyMode=true converts /name[middle] to name[][middle]
            // legacy compatibility mode - index2 only, ex. /name[first] returns value[0][first]
            if ((index1 !== null && index1 !== void 0 ? index1 : '') == '' && (index2 !== null && index2 !== void 0 ? index2 : '') != '')
                return values[0][index2 !== null && index2 !== void 0 ? index2 : '']; // legacy compatibility
            // return values[0].getProperty(objPropertyName)
            if (fullObjValue) {
                return idx >= 0 ? values[0] : values; // legacy compatibility
            }
            else if (values[0] != null) {
                if (objPropertyName in values[0]) {
                    let propKey = objPropertyName;
                    const propValue = values[0][propKey];
                    return propValue; // legacy compatibility
                }
                else
                    throw Error(`Notation error - value object has no property '${objPropertyName}'`);
            }
            else
                throw Error(`Notation error - Cannot extract property '${objPropertyName}' from null value.`);
        }
        default: throw Error(`Invalid notation ${notation}`);
    }
}
class NotationSection {
    constructor(sectionName) {
        this.section = sectionName;
        this.isPresent = false;
        this.startPos = -1;
        this.endPos = -1;
        this.text = null;
        this.parameter = null;
        this.index1 = null;
        this.index2 = null;
    }
}
const EscapeChar = '\\'.charCodeAt(0);
const EscapeChars = '/[]\\'; // /[]\ -> \/ ,\[, \], \\
// Escape the characters in plaintext sections only - title, label or filename
function parseSubsection(text, pos, delimiters, escaped = false) {
    // raw string excludes start delimiter (if '/') but includes end delimiter or both (if '[',']')
    if (!text || pos < 0 || pos >= text.length)
        return null;
    if (!delimiters || delimiters.length > 2)
        throw new Error(`Notation parser: Internal error - Incorrect delimiters count. Delimiters: '${delimiters}'`);
    let token = '';
    let raw = '';
    while (pos < text.length) {
        if (escaped && EscapeChar == text.charCodeAt(pos)) {
            // notation cannot end in single char incomplete escape sequence
            // and only escape_chars should be escaped
            if (((pos + 1) >= text.length) || !EscapeChars.includes(text[pos + 1]))
                throw new Error(`Notation parser: Incorrect escape sequence at position ${pos}`);
            // copy the properly escaped character
            token += text[pos + 1];
            raw += text[pos] + text[pos + 1];
            pos += 2;
        }
        else { // escaped == false || EscapeChar != text.charCodeAt(pos)
            raw += text[pos]; // delimiter is included in raw text
            if (delimiters.length == 1) {
                if (text[pos] == delimiters[0])
                    break;
                else
                    token += text[pos];
            }
            else { // 2 delimiters
                if (raw[0] != delimiters[0])
                    throw new Error(`Notation parser: Index sections must start with '['`);
                if (raw.length > 1 && text[pos] == delimiters[0])
                    throw new Error(`Notation parser: Index sections do not allow extra '[' inside.`);
                if (!delimiters.includes(text[pos]))
                    token += text[pos];
                else if (text[pos] == delimiters[1])
                    break;
            }
            pos++;
        }
    }
    //pos = (pos < text.length) ? pos : text.length - 1
    if (delimiters.length == 2 && ((raw.length < 2 || raw[0] != delimiters[0] || raw[raw.length - 1] != delimiters[1]) ||
        (escaped && raw.charCodeAt(raw.length - 2) == EscapeChar)))
        throw new Error(`Notation parser: Index sections must be enclosed in '[' and ']'`);
    const result = [token, raw];
    return result;
}
function parseSection(notation, section, pos) {
    if (!notation)
        throw new Error(`Keeper notation parsing error - missing notation URI`);
    const sectionName = section.toLowerCase();
    const sections = ['prefix', 'record', 'selector', 'footer'];
    if (!sections.includes(sectionName))
        throw new Error(`Keeper notation parsing error - unknown section: '${sectionName}'`);
    const result = new NotationSection(section);
    result.startPos = pos;
    switch (sectionName) {
        case 'prefix': {
            // prefix 'keeper://' is not mandatory
            const uriPrefix = 'keeper://';
            if (notation.toLowerCase().startsWith(uriPrefix)) {
                result.isPresent = true;
                result.startPos = 0;
                result.endPos = uriPrefix.length - 1;
                result.text = [notation.substring(0, uriPrefix.length), notation.substring(0, uriPrefix.length)];
            }
            break;
        }
        case 'footer': {
            // footer should not be present - used only for verification
            result.isPresent = (pos < notation.length);
            if (result.isPresent) {
                result.startPos = pos;
                result.endPos = notation.length - 1;
                result.text = [notation.substring(pos), notation.substring(pos)];
            }
            break;
        }
        case 'record': {
            // record is always present - either UID or title
            result.isPresent = (pos < notation.length);
            if (result.isPresent) {
                const parsed = parseSubsection(notation, pos, '/', true);
                if (parsed != null) {
                    result.startPos = pos;
                    result.endPos = pos + parsed[1].length - 1;
                    result.text = parsed;
                }
            }
            break;
        }
        case 'selector': {
            // selector is always present - type|title|notes | field|custom_field|file
            result.isPresent = (pos < notation.length);
            if (result.isPresent) {
                let parsed = parseSubsection(notation, pos, '/', false);
                if (parsed != null) {
                    result.startPos = pos;
                    result.endPos = pos + parsed[1].length - 1;
                    result.text = parsed;
                    // selector.parameter - <field type>|<field label> | <file name>
                    // field/name[0][middle], custom_field/my label[0][middle], file/my file[0]
                    const longSelectors = ['field', 'custom_field', 'file'];
                    if (longSelectors.includes(parsed[0].toLowerCase())) {
                        // TODO: File metadata extraction: ex. filename[1][size] - that requires filename to be escaped
                        parsed = parseSubsection(notation, result.endPos + 1, '[', true);
                        if (parsed != null) {
                            result.parameter = parsed; // <field type>|<field label> | <filename>
                            const plen = parsed[1].length - (parsed[1].endsWith('[') && !parsed[1].endsWith('\\[') ? 1 : 0);
                            result.endPos += plen;
                            parsed = parseSubsection(notation, result.endPos + 1, '[]', true);
                            if (parsed != null) {
                                result.index1 = parsed; // selector.index1 [int] or []
                                result.endPos += parsed[1].length;
                                parsed = parseSubsection(notation, result.endPos + 1, '[]', true);
                                if (parsed != null) {
                                    result.index2 = parsed; // selector.index2 [str]
                                    result.endPos += parsed[1].length;
                                }
                            }
                        }
                    }
                }
            }
            break;
        }
        default: throw new Error(`Keeper notation parsing error - unknown section: ${sectionName}`);
    }
    return result;
}
function parseNotation(notation, legacyMode = false) {
    if (!notation)
        throw new Error('Keeper notation is missing or invalid.');
    // Notation is either plaintext keeper URI format or URL safe base64 string (UTF8)
    // auto detect format - '/' is not part of base64 URL safe alphabet
    if (!notation.includes('/')) {
        try {
            var bytes = webSafe64ToBytes(notation);
            var plaintext = new TextDecoder('utf-8').decode(bytes);
            notation = plaintext;
        }
        catch (Exception) {
            throw new Error('Keeper notation is in invalid format - plaintext URI or URL safe base64 string expected.');
        }
    }
    const prefix = parseSection(notation, 'prefix', 0); // keeper://
    let pos = (prefix.isPresent ? prefix.endPos + 1 : 0); // prefix is optional
    const record = parseSection(notation, 'record', pos); // <UID> or <Title>
    pos = (record.isPresent ? record.endPos + 1 : notation.length); // record is required
    const selector = parseSection(notation, 'selector', pos); // type|title|notes | field|custom_field|file
    pos = (selector.isPresent ? selector.endPos + 1 : notation.length); // selector is required, indexes are optional
    const footer = parseSection(notation, 'footer', pos); // Any text after the last section
    // verify parsed query
    // prefix is optional, record UID/Title and selector are mandatory
    const shortSelectors = ['type', 'title', 'notes'];
    const fullSelectors = ['field', 'custom_field', 'file'];
    const selectors = ['type', 'title', 'notes', 'field', 'custom_field', 'file'];
    if (!record.isPresent || !selector.isPresent)
        throw new Error('Keeper notation URI missing information about the uid, file, field type, or field key.');
    if (footer.isPresent)
        throw new Error('Keeper notation is invalid - extra characters after last section.');
    if (selector.text == null || !selectors.includes(selector.text[0].toLowerCase()))
        throw new Error('Keeper notation is invalid - bad selector, must be one of (type, title, notes, field, custom_field, file).');
    if (selector.text != null && shortSelectors.includes(selector.text[0].toLowerCase()) && selector.parameter != null)
        throw new Error('Keeper notation is invalid - selectors (type, title, notes) do not have parameters.');
    if (selector.text != null && fullSelectors.includes(selector.text[0].toLowerCase())) {
        if (selector.parameter == null)
            throw new Error('Keeper notation is invalid - selectors (field, custom_field, file) require parameters.');
        if ('file' == selector.text[0].toLowerCase() && (selector.index1 != null || selector.index2 != null))
            throw new Error('Keeper notation is invalid - file selectors don\'t accept indexes.');
        if ('file' != selector.text[0].toLowerCase() && selector.index1 == null && selector.index2 != null)
            throw new Error('Keeper notation is invalid - two indexes required.');
        if (selector.index1 != null && !/^\[\d*\]$/.test(selector.index1[1])) {
            if (!legacyMode)
                throw new Error('Keeper notation is invalid - first index must be numeric: [n] or [].');
            if (selector.index2 == null) { // in legacy mode convert /name[middle] to name[][middle]
                selector.index2 = selector.index1;
                selector.index1 = ['', '[]'];
            }
        }
    }
    const result = [prefix, record, selector, footer];
    return result;
}

let packageVersion = '16.6.2';
const KEY_HOSTNAME = 'hostname'; // base url for the Secrets Manager service
const KEY_SERVER_PUBLIC_KEY_ID = 'serverPublicKeyId';
const KEY_CLIENT_ID = 'clientId';
const KEY_CLIENT_KEY = 'clientKey'; // The key that is used to identify the client before public key
const KEY_APP_KEY = 'appKey'; // The application key with which all secrets are encrypted
const KEY_OWNER_PUBLIC_KEY = 'appOwnerPublicKey'; // The application owner public key, to create records
const KEY_PRIVATE_KEY = 'privateKey'; // The client's private key
const CLIENT_ID_HASH_TAG = 'KEEPER_SECRETS_MANAGER_CLIENT_ID'; // Tag for hashing the client key to client id
let keeperPublicKeys;
const initialize = (pkgVersion) => {
    if (pkgVersion) {
        packageVersion = pkgVersion;
    }
    let keyNumber = 7;
    keeperPublicKeys = [
        'BK9w6TZFxE6nFNbMfIpULCup2a8xc6w2tUTABjxny7yFmxW0dAEojwC6j6zb5nTlmb1dAx8nwo3qF7RPYGmloRM',
        'BKnhy0obglZJK-igwthNLdknoSXRrGB-mvFRzyb_L-DKKefWjYdFD2888qN1ROczz4n3keYSfKz9Koj90Z6w_tQ',
        'BAsPQdCpLIGXdWNLdAwx-3J5lNqUtKbaOMV56hUj8VzxE2USLHuHHuKDeno0ymJt-acxWV1xPlBfNUShhRTR77g',
        'BNYIh_Sv03nRZUUJveE8d2mxKLIDXv654UbshaItHrCJhd6cT7pdZ_XwbdyxAOCWMkBb9AZ4t1XRCsM8-wkEBRg',
        'BA6uNfeYSvqagwu4TOY6wFK4JyU5C200vJna0lH4PJ-SzGVXej8l9dElyQ58_ljfPs5Rq6zVVXpdDe8A7Y3WRhk',
        'BMjTIlXfohI8TDymsHxo0DqYysCy7yZGJ80WhgOBR4QUd6LBDA6-_318a-jCGW96zxXKMm8clDTKpE8w75KG-FY',
        'BJBDU1P1H21IwIdT2brKkPqbQR0Zl0TIHf7Bz_OO9jaNgIwydMkxt4GpBmkYoprZ_DHUGOrno2faB7pmTR7HhuI',
        'BJFF8j-dH7pDEw_U347w2CBM6xYM8Dk5fPPAktjib-opOqzvvbsER-WDHM4ONCSBf9O_obAHzCyygxmtpktDuiE',
        'BDKyWBvLbyZ-jMueORl3JwJnnEpCiZdN7yUvT0vOyjwpPBCDf6zfL4RWzvSkhAAFnwOni_1tQSl8dfXHbXqXsQ8',
        'BDXyZZnrl0tc2jdC5I61JjwkjK2kr7uet9tZjt8StTiJTAQQmnVOYBgbtP08PWDbecxnHghx3kJ8QXq1XE68y8c',
        'BFX68cb97m9_sweGdOVavFM3j5ot6gveg6xT4BtGahfGhKib-zdZyO9pwvv1cBda9ahkSzo1BQ4NVXp9qRyqVGU'
    ].reduce((keys, key) => {
        keys[keyNumber++] = webSafe64ToBytes(key);
        return keys;
    }, {});
};
const prepareGetPayload = (storage, queryOptions) => __awaiter(void 0, void 0, void 0, function* () {
    const clientId = yield storage.getString(KEY_CLIENT_ID);
    if (!clientId) {
        throw new Error('Client Id is missing from the configuration');
    }
    const payload = {
        clientVersion: 'ms' + packageVersion,
        clientId: clientId
    };
    const appKey = yield storage.getBytes(KEY_APP_KEY);
    if (!appKey) {
        const publicKey = yield platform.exportPublicKey(KEY_PRIVATE_KEY, storage);
        payload.publicKey = platform.bytesToBase64(publicKey);
    }
    if (queryOptions === null || queryOptions === void 0 ? void 0 : queryOptions.recordsFilter) {
        payload.requestedRecords = queryOptions.recordsFilter;
    }
    if (queryOptions === null || queryOptions === void 0 ? void 0 : queryOptions.foldersFilter) {
        payload.requestedFolders = queryOptions.foldersFilter;
    }
    return payload;
});
const prepareUpdatePayload = (storage, record) => __awaiter(void 0, void 0, void 0, function* () {
    const clientId = yield storage.getString(KEY_CLIENT_ID);
    if (!clientId) {
        throw new Error('Client Id is missing from the configuration');
    }
    const recordBytes = platform.stringToBytes(JSON.stringify(record.data));
    const encryptedRecord = yield platform.encrypt(recordBytes, record.recordUid);
    return {
        clientVersion: 'ms' + packageVersion,
        clientId: clientId,
        recordUid: record.recordUid,
        data: webSafe64FromBytes(encryptedRecord),
        revision: record.revision
    };
});
const prepareDeletePayload = (storage, recordUids) => __awaiter(void 0, void 0, void 0, function* () {
    const clientId = yield storage.getString(KEY_CLIENT_ID);
    if (!clientId) {
        throw new Error('Client Id is missing from the configuration');
    }
    return {
        clientVersion: 'ms' + packageVersion,
        clientId: clientId,
        recordUids: recordUids
    };
});
const prepareDeleteFolderPayload = (storage, folderUids, forceDeletion = false) => __awaiter(void 0, void 0, void 0, function* () {
    const clientId = yield storage.getString(KEY_CLIENT_ID);
    if (!clientId) {
        throw new Error('Client Id is missing from the configuration');
    }
    return {
        clientVersion: 'ms' + packageVersion,
        clientId: clientId,
        folderUids: folderUids,
        forceDeletion: forceDeletion
    };
});
const prepareCreatePayload = (storage, createOptions, recordData) => __awaiter(void 0, void 0, void 0, function* () {
    const clientId = yield storage.getString(KEY_CLIENT_ID);
    if (!clientId) {
        throw new Error('Client Id is missing from the configuration');
    }
    const ownerPublicKey = yield storage.getBytes(KEY_OWNER_PUBLIC_KEY);
    if (!ownerPublicKey) {
        throw new Error('Application owner public key is missing from the configuration');
    }
    const recordBytes = platform.stringToBytes(JSON.stringify(recordData));
    const recordKey = platform.getRandomBytes(32);
    const recordUid = platform.getRandomBytes(16);
    const encryptedRecord = yield platform.encryptWithKey(recordBytes, recordKey);
    const encryptedRecordKey = yield platform.publicEncrypt(recordKey, ownerPublicKey);
    const encryptedFolderKey = yield platform.encrypt(recordKey, createOptions.folderUid);
    return {
        clientVersion: 'ms' + packageVersion,
        clientId: clientId,
        recordUid: webSafe64FromBytes(recordUid),
        recordKey: platform.bytesToBase64(encryptedRecordKey),
        folderUid: createOptions.folderUid,
        folderKey: platform.bytesToBase64(encryptedFolderKey),
        data: webSafe64FromBytes(encryptedRecord),
        subFolderUid: createOptions.subFolderUid
    };
});
const prepareCreateFolderPayload = (storage, createOptions, folderName) => __awaiter(void 0, void 0, void 0, function* () {
    const clientId = yield storage.getString(KEY_CLIENT_ID);
    if (!clientId) {
        throw new Error('Client Id is missing from the configuration');
    }
    const folderDataBytes = platform.stringToBytes(JSON.stringify({
        name: folderName
    }));
    const folderKey = platform.getRandomBytes(32);
    const folderUid = platform.getRandomBytes(16);
    const encryptedFolderData = yield platform.encryptWithKey(folderDataBytes, folderKey, true);
    const encryptedFolderKey = yield platform.encrypt(folderKey, createOptions.folderUid, undefined, true);
    return {
        clientVersion: 'ms' + packageVersion,
        clientId: clientId,
        folderUid: webSafe64FromBytes(folderUid),
        sharedFolderUid: createOptions.folderUid,
        sharedFolderKey: webSafe64FromBytes(encryptedFolderKey),
        data: webSafe64FromBytes(encryptedFolderData),
        parentUid: createOptions.subFolderUid
    };
});
const prepareUpdateFolderPayload = (storage, folderUid, folderName) => __awaiter(void 0, void 0, void 0, function* () {
    const clientId = yield storage.getString(KEY_CLIENT_ID);
    if (!clientId) {
        throw new Error('Client Id is missing from the configuration');
    }
    const folderDataBytes = platform.stringToBytes(JSON.stringify({
        name: folderName
    }));
    const encryptedFolderData = yield platform.encrypt(folderDataBytes, folderUid, undefined, true);
    return {
        clientVersion: 'ms' + packageVersion,
        clientId: clientId,
        folderUid: folderUid,
        data: webSafe64FromBytes(encryptedFolderData)
    };
});
const prepareFileUploadPayload = (storage, ownerRecord, file) => __awaiter(void 0, void 0, void 0, function* () {
    const clientId = yield storage.getString(KEY_CLIENT_ID);
    if (!clientId) {
        throw new Error('Client Id is missing from the configuration');
    }
    const ownerPublicKey = yield storage.getBytes(KEY_OWNER_PUBLIC_KEY);
    if (!ownerPublicKey) {
        throw new Error('Application owner public key is missing from the configuration');
    }
    const fileData = {
        name: file.name,
        size: file.data.length,
        title: file.title,
        lastModified: new Date().getTime(),
        type: file.type
    };
    const fileRecordBytes = platform.stringToBytes(JSON.stringify(fileData));
    const fileRecordKey = platform.getRandomBytes(32);
    const fileRecordUid = webSafe64FromBytes(platform.getRandomBytes(16));
    const encryptedFileRecord = yield platform.encryptWithKey(fileRecordBytes, fileRecordKey);
    const encryptedFileRecordKey = yield platform.publicEncrypt(fileRecordKey, ownerPublicKey);
    const encryptedLinkKey = yield platform.encrypt(fileRecordKey, ownerRecord.recordUid);
    const encryptedFileData = yield platform.encryptWithKey(file.data, fileRecordKey);
    let fileRef = ownerRecord.data.fields.find(x => x.type == 'fileRef');
    if (fileRef) {
        fileRef.value.push(fileRecordUid);
    }
    else {
        fileRef = { type: 'fileRef', value: [fileRecordUid] };
        ownerRecord.data.fields.push(fileRef);
    }
    const ownerRecordBytes = platform.stringToBytes(JSON.stringify(ownerRecord.data));
    const encryptedOwnerRecord = yield platform.encrypt(ownerRecordBytes, ownerRecord.recordUid);
    return {
        payload: {
            clientVersion: 'ms' + packageVersion,
            clientId: clientId,
            fileRecordUid: fileRecordUid,
            fileRecordKey: platform.bytesToBase64(encryptedFileRecordKey),
            fileRecordData: webSafe64FromBytes(encryptedFileRecord),
            ownerRecordUid: ownerRecord.recordUid,
            ownerRecordData: webSafe64FromBytes(encryptedOwnerRecord),
            linkKey: platform.bytesToBase64(encryptedLinkKey),
            fileSize: encryptedFileData.length
        },
        encryptedFileData
    };
});
const postFunction = (url, transmissionKey, payload, allowUnverifiedCertificate) => __awaiter(void 0, void 0, void 0, function* () {
    return platform.post(url, payload.payload, {
        PublicKeyId: transmissionKey.publicKeyId.toString(),
        TransmissionKey: platform.bytesToBase64(transmissionKey.encryptedKey),
        Authorization: `Signature ${platform.bytesToBase64(payload.signature)}`
    }, allowUnverifiedCertificate);
});
const generateTransmissionKey = (storage) => __awaiter(void 0, void 0, void 0, function* () {
    const transmissionKey = platform.getRandomBytes(32);
    const keyNumberString = yield storage.getString(KEY_SERVER_PUBLIC_KEY_ID);
    const keyNumber = keyNumberString ? Number(keyNumberString) : 7;
    const keeperPublicKey = keeperPublicKeys[keyNumber];
    if (!keeperPublicKey) {
        throw new Error(`Key number ${keyNumber} is not supported`);
    }
    const encryptedKey = yield platform.publicEncrypt(transmissionKey, keeperPublicKeys[keyNumber]);
    return {
        publicKeyId: keyNumber,
        key: transmissionKey,
        encryptedKey: encryptedKey
    };
});
const encryptAndSignPayload = (storage, transmissionKey, payload) => __awaiter(void 0, void 0, void 0, function* () {
    const payloadBytes = platform.stringToBytes(JSON.stringify(payload));
    const encryptedPayload = yield platform.encryptWithKey(payloadBytes, transmissionKey.key);
    const signatureBase = Uint8Array.of(...transmissionKey.encryptedKey, ...encryptedPayload);
    const signature = yield platform.sign(signatureBase, KEY_PRIVATE_KEY, storage);
    return { payload: encryptedPayload, signature };
});
const postQuery = (options, path, payload) => __awaiter(void 0, void 0, void 0, function* () {
    const hostName = yield options.storage.getString(KEY_HOSTNAME);
    if (!hostName) {
        throw new Error('hostname is missing from the configuration');
    }
    const url = `https://${hostName}/api/rest/sm/v1/${path}`;
    while (true) {
        const transmissionKey = yield generateTransmissionKey(options.storage);
        const encryptedPayload = yield encryptAndSignPayload(options.storage, transmissionKey, payload);
        const response = yield (options.queryFunction || postFunction)(url, transmissionKey, encryptedPayload, options.allowUnverifiedCertificate);
        if (response.statusCode !== 200) {
            let errorMessage;
            if (response.data) {
                errorMessage = platform.bytesToString(response.data.slice(0, 1000));
                try {
                    const errorObj = JSON.parse(errorMessage);
                    if (errorObj.error === 'key') {
                        yield options.storage.saveString(KEY_SERVER_PUBLIC_KEY_ID, errorObj.key_id.toString());
                        continue;
                    }
                }
                catch (_a) {
                }
            }
            else {
                errorMessage = `unknown ksm error, code ${response.statusCode}`;
            }
            throw new Error(errorMessage);
        }
        return response.data
            ? platform.decryptWithKey(response.data, transmissionKey.key)
            : new Uint8Array();
    }
});
const decryptRecord = (record, storage) => __awaiter(void 0, void 0, void 0, function* () {
    const decryptedRecord = yield platform.decrypt(platform.base64ToBytes(record.data), record.recordUid || KEY_APP_KEY, storage);
    const keeperRecord = {
        recordUid: record.recordUid,
        data: JSON.parse(platform.bytesToString(decryptedRecord)),
        revision: record.revision,
    };
    if (record.innerFolderUid) {
        keeperRecord.innerFolderUid = record.innerFolderUid;
    }
    if (record.files) {
        keeperRecord.files = [];
        for (const file of record.files) {
            yield platform.unwrap(platform.base64ToBytes(file.fileKey), file.fileUid, record.recordUid || KEY_APP_KEY);
            const decryptedFile = yield platform.decrypt(platform.base64ToBytes(file.data), file.fileUid);
            keeperRecord.files.push({
                fileUid: file.fileUid,
                data: JSON.parse(platform.bytesToString(decryptedFile)),
                url: file.url,
                thumbnailUrl: file.thumbnailUrl
            });
        }
    }
    return keeperRecord;
});
const fetchAndDecryptSecrets = (options, queryOptions) => __awaiter(void 0, void 0, void 0, function* () {
    const storage = options.storage;
    const payload = yield prepareGetPayload(storage, queryOptions);
    const responseData = yield postQuery(options, 'get_secret', payload);
    const response = JSON.parse(platform.bytesToString(responseData));
    const records = [];
    let justBound = false;
    if (response.encryptedAppKey) {
        justBound = true;
        yield platform.unwrap(platform.base64ToBytes(response.encryptedAppKey), KEY_APP_KEY, KEY_CLIENT_KEY, storage);
        yield storage.delete(KEY_CLIENT_KEY);
        yield storage.saveString(KEY_OWNER_PUBLIC_KEY, response.appOwnerPublicKey);
    }
    if (response.records) {
        for (const record of response.records) {
            if (record.recordKey) {
                yield platform.unwrap(platform.base64ToBytes(record.recordKey), record.recordUid, KEY_APP_KEY, storage, true);
            }
            const decryptedRecord = yield decryptRecord(record, storage);
            records.push(decryptedRecord);
        }
    }
    if (response.folders) {
        for (const folder of response.folders) {
            yield platform.unwrap(platform.base64ToBytes(folder.folderKey), folder.folderUid, KEY_APP_KEY, storage, true);
            for (const record of folder.records) {
                yield platform.unwrap(platform.base64ToBytes(record.recordKey), record.recordUid, folder.folderUid);
                const decryptedRecord = yield decryptRecord(record);
                decryptedRecord.folderUid = folder.folderUid;
                records.push(decryptedRecord);
            }
        }
    }
    let appData;
    if (response.appData) {
        appData = JSON.parse(platform.bytesToString(yield platform.decrypt(webSafe64ToBytes(response.appData), KEY_APP_KEY, storage)));
    }
    const secrets = {
        appData: appData,
        expiresOn: response.expiresOn > 0 ? new Date(response.expiresOn) : undefined,
        records: records
    };
    if (response.warnings && response.warnings.length > 0) {
        secrets.warnings = response.warnings;
    }
    if (response.extra && Object.keys(response.extra).length > 0) {
        secrets.extra = response.extra;
    }
    return { secrets, justBound };
});
const getSharedFolderUid = (folders, parent) => {
    while (true) {
        const parentFolder = folders.find(x => x.folderUid === parent);
        if (!parentFolder) {
            return undefined;
        }
        if (parentFolder.parent) {
            parent = parentFolder.parent;
        }
        else {
            return parent;
        }
    }
};
const fetchAndDecryptFolders = (options) => __awaiter(void 0, void 0, void 0, function* () {
    const storage = options.storage;
    const payload = yield prepareGetPayload(storage);
    const responseData = yield postQuery(options, 'get_folders', payload);
    const response = JSON.parse(platform.bytesToString(responseData));
    const folders = [];
    if (response.folders) {
        for (const folder of response.folders) {
            let decryptedData;
            const decryptedFolder = {
                folderUid: folder.folderUid
            };
            if (folder.parent) {
                decryptedFolder.parentUid = folder.parent;
                const sharedFolderUid = getSharedFolderUid(response.folders, folder.parent);
                if (!sharedFolderUid) {
                    throw new Error('Folder data inconsistent - unable to locate shared folder');
                }
                yield platform.unwrap(platform.base64ToBytes(folder.folderKey), folder.folderUid, sharedFolderUid, storage, true, true);
                decryptedData = yield platform.decrypt(platform.base64ToBytes(folder.data), folder.folderUid, storage, true);
            }
            else {
                yield platform.unwrap(platform.base64ToBytes(folder.folderKey), folder.folderUid, KEY_APP_KEY, storage, true);
                decryptedData = yield platform.decrypt(platform.base64ToBytes(folder.data), folder.folderUid, storage, true);
            }
            decryptedFolder.name = JSON.parse(platform.bytesToString(decryptedData))['name'];
            folders.push(decryptedFolder);
        }
    }
    return folders;
});
const getClientId = (clientKey) => __awaiter(void 0, void 0, void 0, function* () {
    const clientKeyHash = yield platform.hash(webSafe64ToBytes(clientKey), CLIENT_ID_HASH_TAG);
    return platform.bytesToBase64(clientKeyHash);
});
const initializeStorage = (storage, oneTimeToken, hostName) => __awaiter(void 0, void 0, void 0, function* () {
    const tokenParts = oneTimeToken.split(':');
    let host, clientKey;
    if (tokenParts.length === 1) {
        if (!hostName) {
            throw new Error('The hostname must be present in the token or as a parameter');
        }
        host = hostName;
        clientKey = oneTimeToken;
    }
    else {
        host = {
            US: 'keepersecurity.com',
            EU: 'keepersecurity.eu',
            AU: 'keepersecurity.com.au',
            GOV: 'govcloud.keepersecurity.us',
            JP: 'keepersecurity.jp',
            CA: 'keepersecurity.ca'
        }[tokenParts[0].toUpperCase()];
        if (!host) {
            host = tokenParts[0];
        }
        clientKey = tokenParts[1];
    }
    const clientKeyBytes = webSafe64ToBytes(clientKey);
    const clientKeyHash = yield platform.hash(clientKeyBytes, CLIENT_ID_HASH_TAG);
    const clientId = platform.bytesToBase64(clientKeyHash);
    const existingClientId = yield storage.getString(KEY_CLIENT_ID);
    if (existingClientId) {
        if (existingClientId === clientId) {
            return; // the storage is already initialized
        }
        throw new Error(`The storage is already initialized with a different client Id (${existingClientId})`);
    }
    yield storage.saveString(KEY_HOSTNAME, host);
    yield storage.saveString(KEY_CLIENT_ID, clientId);
    yield platform.importKey(KEY_CLIENT_KEY, clientKeyBytes, storage);
    yield platform.generatePrivateKey(KEY_PRIVATE_KEY, storage);
});
const getSecrets = (options, recordsFilter) => __awaiter(void 0, void 0, void 0, function* () {
    const queryOptions = recordsFilter
        ? { recordsFilter: recordsFilter }
        : undefined;
    return getSecrets2(options, queryOptions);
});
const getSecrets2 = (options, queryOptions) => __awaiter(void 0, void 0, void 0, function* () {
    platform.cleanKeyCache();
    const { secrets, justBound } = yield fetchAndDecryptSecrets(options, queryOptions);
    if (justBound) {
        try {
            yield fetchAndDecryptSecrets(options, queryOptions);
        }
        catch (e) {
            console.error(e);
        }
    }
    return secrets;
});
const getFolders = (options) => __awaiter(void 0, void 0, void 0, function* () {
    platform.cleanKeyCache();
    return yield fetchAndDecryptFolders(options);
});
// tryGetNotationResults returns a string list with all values specified by the notation or empty list on error.
// It simply logs any errors and continue returning an empty string list on error.
const tryGetNotationResults = (options, notation) => __awaiter(void 0, void 0, void 0, function* () {
    try {
        return yield getNotationResults(options, notation);
    }
    catch (e) {
        console.error(e);
    }
    return [];
});
// Notation:
// keeper://<uid|title>/<field|custom_field>/<type|label>[INDEX][PROPERTY]
// keeper://<uid|title>/file/<filename|fileUID>
// Record title, field label, filename sections need to escape the delimiters /[]\ -> \/ \[ \] \\
//
// GetNotationResults returns selection of the value(s) from a single field as a string list.
// Multiple records or multiple fields found results in error.
// Use record UID or unique record titles and field labels so that notation finds a single record/field.
//
// If field has multiple values use indexes - numeric INDEX specifies the position in the value list
// and PROPERTY specifies a single JSON object property to extract (see examples below for usage)
// If no indexes are provided - whole value list is returned (same as [])
// If PROPERTY is provided then INDEX must be provided too - even if it's empty [] which means all
//
// Extracting two or more but not all field values simultaneously is not supported - use multiple notation requests.
//
// Files are returned as URL safe base64 encoded string of the binary content
//
// Note: Integrations and plugins usually return single string value - result[0] or ''
//
// Examples:
//  RECORD_UID/file/filename.ext             => ['URL Safe Base64 encoded binary content']
//  RECORD_UID/field/url                     => ['127.0.0.1', '127.0.0.2'] or [] if empty
//  RECORD_UID/field/url[]                   => ['127.0.0.1', '127.0.0.2'] or [] if empty
//  RECORD_UID/field/url[0]                  => ['127.0.0.1'] or error if empty
//  RECORD_UID/custom_field/name[first]      => Error, numeric index is required to access field property
//  RECORD_UID/custom_field/name[][last]     => ['Smith', 'Johnson']
//  RECORD_UID/custom_field/name[0][last]    => ['Smith']
//  RECORD_UID/custom_field/phone[0][number] => '555-5555555'
//  RECORD_UID/custom_field/phone[1][number] => '777-7777777'
//  RECORD_UID/custom_field/phone[]          => ['{\'number\': \'555-555...\'}', '{\'number\': \'777...\'}']
//  RECORD_UID/custom_field/phone[0]         => ['{\'number\': \'555-555...\'}']
// getNotationResults returns a string list with all values specified by the notation or throws an error.
// Use tryGetNotationResults() to just log errors and continue returning an empty string list on error.
const getNotationResults = (options, notation) => __awaiter(void 0, void 0, void 0, function* () {
    var _b, _c, _d, _e;
    let result = [];
    const parsedNotation = parseNotation(notation); // prefix, record, selector, footer
    if (parsedNotation.length < 3)
        throw new Error(`Invalid notation ${notation}`);
    if (parsedNotation[1].text == null)
        throw new Error(`Invalid notation ${notation}`);
    const recordToken = parsedNotation[1].text[0]; // UID or Title
    if (parsedNotation[2].text == null)
        throw new Error(`Invalid notation ${notation}`);
    const selector = parsedNotation[2].text[0]; // type|title|notes or file|field|custom_field
    // to minimize traffic - if it looks like a Record UID try to pull a single record
    let records = [];
    if (/^[A-Za-z0-9_-]{22}$/.test(recordToken)) {
        const secrets = yield getSecrets(options, [recordToken]);
        records = secrets.records;
        if (records.length > 1)
            throw new Error(`Notation error - found multiple records with same UID '${recordToken}'`);
    }
    // If RecordUID is not found - pull all records and search by title
    if (records.length < 1) {
        const secrets = yield getSecrets(options);
        if ((secrets === null || secrets === void 0 ? void 0 : secrets.records) != null)
            records = yield findSecretsByTitle(secrets.records, recordToken);
    }
    if (records.length > 1)
        throw new Error(`Notation error - multiple records match record '${recordToken}'`);
    if (records.length < 1)
        throw new Error(`Notation error - no records match record '${recordToken}'`);
    const record = records[0];
    const parameter = parsedNotation[2].parameter != null ? parsedNotation[2].parameter[0] : '';
    const index1 = parsedNotation[2].index1 != null ? parsedNotation[2].index1[0] : '';
    parsedNotation[2].index2 != null ? parsedNotation[2].index2[0] : '';
    switch (selector.toLowerCase()) {
        case 'type': {
            if (((_b = record === null || record === void 0 ? void 0 : record.data) === null || _b === void 0 ? void 0 : _b.type) != null)
                result.push(record.data.type);
            break;
        }
        case 'title': {
            if (((_c = record === null || record === void 0 ? void 0 : record.data) === null || _c === void 0 ? void 0 : _c.title) != null)
                result.push(record.data.title);
            break;
        }
        case 'notes': {
            if (((_d = record === null || record === void 0 ? void 0 : record.data) === null || _d === void 0 ? void 0 : _d.notes) != null)
                result.push(record.data.notes);
            break;
        }
        case 'file': {
            if (parameter == null)
                throw new Error(`Notation error - Missing required parameter: filename or file UID for files in record '${recordToken}'`);
            if ((((_e = record === null || record === void 0 ? void 0 : record.files) === null || _e === void 0 ? void 0 : _e.length) || 0) < 1)
                throw new Error(`Notation error - Record ${recordToken} has no file attachments.`);
            let files = record.files.filter(x => { var _a; return parameter == ((_a = x === null || x === void 0 ? void 0 : x.data) === null || _a === void 0 ? void 0 : _a.name) || parameter == x.fileUid; });
            // file searches do not use indexes and rely on unique file names or fileUid
            const numFiles = (files == null ? 0 : files.length);
            if (numFiles > 1)
                throw new Error(`Notation error - Record ${recordToken} has multiple files matching the search criteria '${parameter}'`);
            if (numFiles < 1)
                throw new Error(`Notation error - Record ${recordToken} has no files matching the search criteria '${parameter}'`);
            const contents = yield downloadFile(files[0]);
            const text = webSafe64FromBytes(contents);
            result.push(text);
            break;
        }
        case 'field':
        case 'custom_field': {
            if (parsedNotation[2].parameter == null)
                throw new Error('Notation error - Missing required parameter for the field (type or label): ex. /field/type or /custom_field/MyLabel');
            const fields = (selector.toLowerCase() == 'field' ? record.data.fields :
                selector.toLowerCase() == 'custom_field' ? record.data.custom : null);
            if (!fields)
                throw new Error(`Notation error - Expected /field or /custom_field but found /${selector}`);
            const flds = fields.filter(x => parameter == x.type || parameter == x.label);
            if (((flds === null || flds === void 0 ? void 0 : flds.length) || 0) > 1)
                throw new Error(`Notation error - Record ${recordToken} has multiple fields matching the search criteria '${parameter}'`);
            if (((flds === null || flds === void 0 ? void 0 : flds.length) || 0) < 1)
                throw new Error(`Notation error - Record ${recordToken} has no fields matching the search criteria '${parameter}'`);
            const field = flds[0];
            //const fieldType = field?.type || ''
            const idx = tryParseInt(index1, -1); // -1 = full value
            // valid only if [] or missing - ex. /field/phone or /field/phone[]
            if (idx == -1 && !(parsedNotation[2].index1 == null || parsedNotation[2].index1[1] == '' || parsedNotation[2].index1[1] == '[]'))
                throw new Error(`Notation error - Invalid field index ${idx}.`);
            let values = ((field === null || field === void 0 ? void 0 : field.value) != null ? field.value : []);
            if (idx >= values.length)
                throw new Error(`Notation error - Field index out of bounds ${idx} >= ${values.length} for field ${parameter}`);
            if (idx >= 0) // single index
                values = [values[idx]];
            const fullObjValue = (parsedNotation[2].index2 == null || parsedNotation[2].index2[1] == '' || parsedNotation[2].index2[1] == '[]');
            let objPropertyName = '';
            if (parsedNotation[2].index2 != null)
                objPropertyName = parsedNotation[2].index2[0];
            const res = [];
            for (let i = 0; i < values.length; i++) {
                const fldValue = values[i];
                // Do not throw here to allow for ex. field/name[][middle] to pull [middle] only where present
                // NB! Not all properties of a value are always required even when the field is marked as required
                // ex. On a required `name` field only 'first' and 'last' properties are required but not 'middle'
                // so missing property in a field value is not always an error
                if (fldValue == null)
                    console.log('Notation error - Empty field value for field ', parameter); // throw?
                if (fullObjValue) {
                    res.push(typeof fldValue === 'string' ? fldValue : JSON.stringify(fldValue));
                }
                else if (fldValue != null) {
                    if (objPropertyName in fldValue) {
                        let propKey = objPropertyName;
                        const propValue = fldValue[propKey];
                        res.push(typeof propValue === 'string' ? propValue : JSON.stringify(propValue));
                    }
                    else
                        console.log(`Notation error - value object has no property '${objPropertyName}'`); // skip
                }
                else
                    console.log(`Notation error - Cannot extract property '${objPropertyName}' from null value.`);
            }
            if (res.length != values.length)
                console.log(`Notation warning - extracted ${res.length} out of ${values.length} values for '${objPropertyName}' property.`);
            if (res.length > 0)
                result.push.apply(result, res);
            break;
        }
        default: {
            throw new Error(`Invalid notation ${notation}`);
        }
    }
    return result;
});
const findSecretsByTitle = (records, recordTitle) => __awaiter(void 0, void 0, void 0, function* () {
    return records.filter(record => record.data.title === recordTitle);
});
const findSecretByTitle = (records, recordTitle) => __awaiter(void 0, void 0, void 0, function* () {
    return records.find(record => record.data.title === recordTitle);
});
const getSecretsByTitle = (options, recordTitle) => __awaiter(void 0, void 0, void 0, function* () {
    const secrets = yield getSecrets(options);
    return secrets.records.filter(record => record.data.title === recordTitle);
});
const getSecretByTitle = (options, recordTitle) => __awaiter(void 0, void 0, void 0, function* () {
    const secrets = yield getSecrets(options);
    return secrets.records.find(record => record.data.title === recordTitle);
});
const updateSecret = (options, record) => __awaiter(void 0, void 0, void 0, function* () {
    const payload = yield prepareUpdatePayload(options.storage, record);
    yield postQuery(options, 'update_secret', payload);
});
const deleteSecret = (options, recordUids) => __awaiter(void 0, void 0, void 0, function* () {
    const payload = yield prepareDeletePayload(options.storage, recordUids);
    const responseData = yield postQuery(options, 'delete_secret', payload);
    return JSON.parse(platform.bytesToString(responseData));
});
const deleteFolder = (options, folderUids, forceDeletion) => __awaiter(void 0, void 0, void 0, function* () {
    const payload = yield prepareDeleteFolderPayload(options.storage, folderUids, forceDeletion);
    const responseData = yield postQuery(options, 'delete_folder', payload);
    return JSON.parse(platform.bytesToString(responseData));
});
const createSecret = (options, folderUid, recordData) => __awaiter(void 0, void 0, void 0, function* () {
    if (!platform.hasKeysCached()) {
        yield getSecrets(options); // need to warm up keys cache before posting a record
    }
    const payload = yield prepareCreatePayload(options.storage, { folderUid: folderUid }, recordData);
    yield postQuery(options, 'create_secret', payload);
    return payload.recordUid;
});
const createSecret2 = (options, createOptions, recordData) => __awaiter(void 0, void 0, void 0, function* () {
    if (!platform.hasKeysCached()) {
        yield getFolders(options); // need to warm up keys cache before posting a record
    }
    const payload = yield prepareCreatePayload(options.storage, createOptions, recordData);
    yield postQuery(options, 'create_secret', payload);
    return payload.recordUid;
});
const createFolder = (options, createOptions, folderName) => __awaiter(void 0, void 0, void 0, function* () {
    if (!platform.hasKeysCached()) {
        yield getSecrets(options); // need to warm up keys cache before posting a record
    }
    const payload = yield prepareCreateFolderPayload(options.storage, createOptions, folderName);
    yield postQuery(options, 'create_folder', payload);
    return payload.folderUid;
});
const updateFolder = (options, folderUid, folderName) => __awaiter(void 0, void 0, void 0, function* () {
    if (!platform.hasKeysCached()) {
        yield getSecrets(options); // need to warm up keys cache before posting a record
    }
    const payload = yield prepareUpdateFolderPayload(options.storage, folderUid, folderName);
    yield postQuery(options, 'update_folder', payload);
});
const downloadFile = (file) => __awaiter(void 0, void 0, void 0, function* () {
    const fileResponse = yield platform.get(file.url, {});
    return platform.decrypt(fileResponse.data, file.fileUid);
});
const downloadThumbnail = (file) => __awaiter(void 0, void 0, void 0, function* () {
    const fileResponse = yield platform.get(file.thumbnailUrl, {});
    return platform.decrypt(fileResponse.data, file.fileUid);
});
const uploadFile = (options, ownerRecord, file) => __awaiter(void 0, void 0, void 0, function* () {
    const { payload, encryptedFileData } = yield prepareFileUploadPayload(options.storage, ownerRecord, file);
    const responseData = yield postQuery(options, 'add_file', payload);
    const response = JSON.parse(platform.bytesToString(responseData));
    const uploadResult = yield platform.fileUpload(response.url, JSON.parse(response.parameters), encryptedFileData);
    if (uploadResult.statusCode !== response.successStatusCode) {
        throw new Error(`Upload failed (${uploadResult.statusMessage}), code ${uploadResult.statusCode}`);
    }
    return payload.fileRecordUid;
});
const addCustomField = (record, field) => {
    if (record.data.custom == null || record.data.custom == undefined)
        record.data.custom = [];
    record.data.custom.push(field);
};
class KeeperRecordField {
    constructor() {
        this.type = '';
    }
}
class LoginField extends KeeperRecordField {
    constructor(value) {
        super();
        this.type = 'login';
        this.value = [value];
    }
}
class PasswordField extends KeeperRecordField {
    constructor(value) {
        super();
        this.type = 'password';
        this.value = [value];
    }
}
class UrlField extends KeeperRecordField {
    constructor(value) {
        super();
        this.type = 'url';
        this.value = [value];
    }
}
class FileRefField extends KeeperRecordField {
    constructor(value) {
        super();
        this.type = 'fileRef';
        this.value = [value];
    }
}
class OneTimeCodeField extends KeeperRecordField {
    constructor(value) {
        super();
        this.type = 'oneTimeCode';
        this.value = [value];
    }
}
class NameField extends KeeperRecordField {
    constructor(value) {
        super();
        this.type = 'name';
        this.value = [value];
    }
}
class BirthDateField extends KeeperRecordField {
    constructor(value) {
        super();
        this.type = 'birthDate';
        this.value = [value];
    }
}
class DateField extends KeeperRecordField {
    constructor(value) {
        super();
        this.type = 'date';
        this.value = [value];
    }
}
class ExpirationDateField extends KeeperRecordField {
    constructor(value) {
        super();
        this.type = 'expirationDate';
        this.value = [value];
    }
}
class TextField extends KeeperRecordField {
    constructor(value) {
        super();
        this.type = 'text';
        this.value = [value];
    }
}
class SecurityQuestionField extends KeeperRecordField {
    constructor(value) {
        super();
        this.type = 'securityQuestion';
        this.value = [value];
    }
}
class MultilineField extends KeeperRecordField {
    constructor(value) {
        super();
        this.type = 'multiline';
        this.value = [value];
    }
}
class EmailField extends KeeperRecordField {
    constructor(value) {
        super();
        this.type = 'email';
        this.value = [value];
    }
}
class CardRefField extends KeeperRecordField {
    constructor(value) {
        super();
        this.type = 'cardRef';
        this.value = [value];
    }
}
class AddressRefField extends KeeperRecordField {
    constructor(value) {
        super();
        this.type = 'addressRef';
        this.value = [value];
    }
}
class PinCodeField extends KeeperRecordField {
    constructor(value) {
        super();
        this.type = 'pinCode';
        this.value = [value];
    }
}
class PhoneField extends KeeperRecordField {
    constructor(value) {
        super();
        this.type = 'phone';
        this.value = [value];
    }
}
class SecretField extends KeeperRecordField {
    constructor(value) {
        super();
        this.type = 'secret';
        this.value = [value];
    }
}
class SecureNoteField extends KeeperRecordField {
    constructor(value) {
        super();
        this.type = 'note';
        this.value = [value];
    }
}
class AccountNumberField extends KeeperRecordField {
    constructor(value) {
        super();
        this.type = 'accountNumber';
        this.value = [value];
    }
}
class PaymentCardField extends KeeperRecordField {
    constructor(value) {
        super();
        this.type = 'paymentCard';
        this.value = [value];
    }
}
class BankAccountField extends KeeperRecordField {
    constructor(value) {
        super();
        this.type = 'bankAccount';
        this.value = [value];
    }
}
class KeyPairField extends KeeperRecordField {
    constructor(value) {
        super();
        this.type = 'keyPair';
        this.value = [value];
    }
}
class HostField extends KeeperRecordField {
    constructor(value) {
        super();
        this.type = 'host';
        this.value = [value];
    }
}
class AddressField extends KeeperRecordField {
    constructor(value) {
        super();
        this.type = 'address';
        this.value = [value];
    }
}
class LicenseNumberField extends KeeperRecordField {
    constructor(value) {
        super();
        this.type = 'licenseNumber';
        this.value = [value];
    }
}
class RecordRefField extends KeeperRecordField {
    constructor(value) {
        super();
        this.type = 'recordRef';
        this.value = [value];
    }
}
class ScheduleField extends KeeperRecordField {
    constructor(value) {
        super();
        this.type = 'schedule';
        this.value = [value];
    }
}
class ScriptField extends KeeperRecordField {
    constructor(value) {
        super();
        this.type = 'script';
        this.value = [value];
    }
}
class DirectoryTypeField extends KeeperRecordField {
    constructor(value) {
        super();
        this.type = 'directoryType';
        this.value = [value];
    }
}
class DatabaseTypeField extends KeeperRecordField {
    constructor(value) {
        super();
        this.type = 'databaseType';
        this.value = [value];
    }
}
class PamHostnameField extends KeeperRecordField {
    constructor(value) {
        super();
        this.type = 'pamHostname';
        this.value = [value];
    }
}
class PamResourceField extends KeeperRecordField {
    constructor(value) {
        super();
        this.type = 'pamResources';
        this.value = [value];
    }
}
class CheckboxField extends KeeperRecordField {
    constructor(value) {
        super();
        this.type = 'checkbox';
        this.value = [value];
    }
}
class PasskeyField extends KeeperRecordField {
    constructor(value) {
        super();
        this.type = 'passkey';
        this.value = [value];
    }
}

const localConfigStorage = (client, useObjects) => {
    const getObjectStore = (mode) => __awaiter(void 0, void 0, void 0, function* () {
        return new Promise(((resolve, reject) => {
            const request = indexedDB.open(client, 1);
            request.onupgradeneeded = () => {
                request.result.createObjectStore('secrets');
            };
            request.onsuccess = () => {
                resolve(request.result.transaction('secrets', mode).objectStore('secrets'));
            };
        }));
    });
    const getValue = (key) => __awaiter(void 0, void 0, void 0, function* () {
        const objectStore = yield getObjectStore('readonly');
        return new Promise(((resolve, reject) => {
            const request = objectStore.get(key);
            request.onsuccess = () => {
                resolve(request.result);
            };
        }));
    });
    const saveValue = (key, value) => __awaiter(void 0, void 0, void 0, function* () {
        const objectStore = yield getObjectStore('readwrite');
        return new Promise(((resolve, reject) => {
            const request = objectStore.put(value, key);
            request.onsuccess = () => {
                resolve();
            };
        }));
    });
    const deleteValue = (key) => __awaiter(void 0, void 0, void 0, function* () {
        const objectStore = yield getObjectStore('readwrite');
        return new Promise(((resolve, reject) => {
            const request = objectStore.delete(key);
            request.onsuccess = () => {
                resolve();
            };
        }));
    });
    let storage = {
        getString: getValue,
        saveString: saveValue,
        getBytes: getValue,
        saveBytes: saveValue,
        delete: deleteValue
    };
    if (useObjects) {
        storage = Object.assign(Object.assign({}, storage), { getObject: getValue, saveObject: saveValue });
    }
    return storage;
};
function createCachingFunction(storage) {
    return (url, transmissionKey, payload) => __awaiter(this, void 0, void 0, function* () {
        try {
            const response = yield platform.post(url, payload.payload, {
                PublicKeyId: transmissionKey.publicKeyId.toString(),
                TransmissionKey: platform.bytesToBase64(transmissionKey.encryptedKey),
                Authorization: `Signature ${platform.bytesToBase64(payload.signature)}`
            });
            if (response.statusCode == 200) {
                yield storage.saveBytes('cache', Buffer.concat([transmissionKey.key, response.data]));
            }
            return response;
        }
        catch (e) {
            const cachedData = yield storage.getBytes('cache');
            if (!cachedData) {
                throw new Error('Cached value does not exist');
            }
            transmissionKey.key = cachedData.slice(0, 32);
            return {
                statusCode: 200,
                data: cachedData.slice(32),
                headers: []
            };
        }
    });
}

connectPlatform(browserPlatform);
initialize();

export { AccountNumberField, AddressField, AddressRefField, BankAccountField, BirthDateField, CardRefField, CheckboxField, DatabaseTypeField, DateField, DirectoryTypeField, EmailField, ExpirationDateField, FileRefField, HostField, KeeperRecordField, KeyPairField, LicenseNumberField, LoginField, MultilineField, NameField, OneTimeCodeField, PamHostnameField, PamResourceField, PasskeyField, PasswordField, PaymentCardField, PhoneField, PinCodeField, RecordRefField, ScheduleField, ScriptField, SecretField, SecureNoteField, SecurityQuestionField, TextField, UrlField, addCustomField, createCachingFunction, createFolder, createSecret, createSecret2, deleteFolder, deleteSecret, downloadFile, downloadThumbnail, findSecretByTitle, findSecretsByTitle, generatePassword, generateTransmissionKey, getClientId, getFolders, getNotationResults, getSecretByTitle, getSecrets, getSecrets2, getSecretsByTitle, getTotpCode, getValue, inMemoryStorage, initialize, initializeStorage, loadJsonConfig, localConfigStorage, parseNotation, tryGetNotationResults, updateFolder, updateSecret, uploadFile };
//# sourceMappingURL=index.es.js.map
